"use strict";(self.webpackChunktest_api=self.webpackChunktest_api||[]).push([[8581],{5610:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Introduction","href":"/docs/intro","docId":"intro","unlisted":false},{"type":"link","label":"Getting Started with Phlame","href":"/docs/getting-started","docId":"getting-started","unlisted":false},{"type":"category","label":"Routing Guide","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction to Routing","href":"/docs/routing-guide/intro","docId":"routing-guide/intro","unlisted":false},{"type":"link","label":"Static Routing","href":"/docs/routing-guide/static-routing","docId":"routing-guide/static-routing","unlisted":false},{"type":"link","label":"Dynamic Routing","href":"/docs/routing-guide/dynamic-routing","docId":"routing-guide/dynamic-routing","unlisted":false},{"type":"link","label":"Source Type Control","href":"/docs/routing-guide/source-type","docId":"routing-guide/source-type","unlisted":false},{"type":"link","label":"Setting Source File","href":"/docs/routing-guide/setting-source","docId":"routing-guide/setting-source","unlisted":false}],"href":"/docs/category/routing-guide"},{"type":"category","label":"Handling Requests","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction to Requests","href":"/docs/handling-requests/intro","docId":"handling-requests/intro","unlisted":false},{"type":"link","label":"Using the API Class","href":"/docs/handling-requests/api-class","docId":"handling-requests/api-class","unlisted":false},{"type":"link","label":"Request Headers","href":"/docs/handling-requests/headers-method","docId":"handling-requests/headers-method","unlisted":false},{"type":"link","label":"Request Body","href":"/docs/handling-requests/body-method","docId":"handling-requests/body-method","unlisted":false},{"type":"link","label":"Request Parameters","href":"/docs/handling-requests/params-method","docId":"handling-requests/params-method","unlisted":false},{"type":"link","label":"Request Authorization","href":"/docs/handling-requests/auth-method","docId":"handling-requests/auth-method","unlisted":false}],"href":"/docs/category/handling-requests"},{"type":"category","label":"Response Management","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction to Response","href":"/docs/response-management/intro","docId":"response-management/intro","unlisted":false},{"type":"link","label":"Segmentation","href":"/docs/response-management/segmentation","docId":"response-management/segmentation","unlisted":false},{"type":"link","label":"Join","href":"/docs/response-management/join","docId":"response-management/join","unlisted":false},{"type":"link","label":"Send","href":"/docs/response-management/send","docId":"response-management/send","unlisted":false},{"type":"link","label":"Additional Functions","href":"/docs/response-management/additional-functions","docId":"response-management/additional-functions","unlisted":false}],"href":"/docs/category/response-management"},{"type":"link","label":"Phlame Directory Structure","href":"/docs/directory-structure","docId":"directory-structure","unlisted":false}]},"docs":{"directory-structure":{"id":"directory-structure","title":"Phlame Directory Structure","description":"Phlame is a microframework that comes with a default directory structure to help developers organize their projects efficiently. Let\'s explore the default directory structure and guidelines for using Phlame:","sidebar":"tutorialSidebar"},"getting-started":{"id":"getting-started","title":"Getting Started with Phlame","description":"To begin using Phlame, you\'ll need to:","sidebar":"tutorialSidebar"},"handling-requests/api-class":{"id":"handling-requests/api-class","title":"Using the API Class","description":"Phlame provides a built-in API class, which allows you to access parts of the request using simple methods,","sidebar":"tutorialSidebar"},"handling-requests/auth-method":{"id":"handling-requests/auth-method","title":"Request Authorization","description":"The auth function in Phlame provides a streamlined approach to handle authentication within web applications and APIs. This function enables developers to authenticate incoming requests based on authorization headers and tokens, with support for optional prefixing and hashing. Let\'s explore the documentation for the auth function and how it can be used.","sidebar":"tutorialSidebar"},"handling-requests/body-method":{"id":"handling-requests/body-method","title":"Request Body","description":"In Phlame\'s API development toolkit, the body method within the API class provides a straightforward approach to handle HTTP request bodies in incoming requests. This method offers developers flexibility and simplicity, enabling them to process request payloads efficiently and execute custom logic based on the contents. Let\'s explore the syntax and usage of the body method:","sidebar":"tutorialSidebar"},"handling-requests/headers-method":{"id":"handling-requests/headers-method","title":"Request Headers","description":"In Phlame\'s API development toolkit, the headers method within the API class provides a convenient way to handle HTTP headers in incoming requests. This method offers flexibility and ease of use, allowing developers to check for specific headers, retrieve all headers, and execute callbacks based on the results. Let\'s dive into the syntax and usage of the headers method:","sidebar":"tutorialSidebar"},"handling-requests/intro":{"id":"handling-requests/intro","title":"Introduction to Requests","description":"As a developer, understanding how requests are handled in both traditional websites and APIs is crucial for building efficient and scalable web applications. Let\'s explore the concept of requests and how they are processed in both contexts:","sidebar":"tutorialSidebar"},"handling-requests/params-method":{"id":"handling-requests/params-method","title":"Request Parameters","description":"In Phlame\'s API development toolkit, the params method within the API class provides a straightforward approach to handle HTTP request bodies in incoming requests. This method offers developers flexibility and simplicity, enabling them to process request payloads efficiently and execute custom logic based on the contents. Let\'s explore the syntax and usage of the params method:","sidebar":"tutorialSidebar"},"intro":{"id":"intro","title":"Introduction","description":"Phlame is a lightweight and flexible micro-framework designed to streamline and simplify the development of APIs in PHP. This documentation guide will introduce you to the core functionalities, setup process, and basic usage of Phlame.","sidebar":"tutorialSidebar"},"response-management/additional-functions":{"id":"response-management/additional-functions","title":"Additional Functions","description":"You have additional functions such as","sidebar":"tutorialSidebar"},"response-management/intro":{"id":"response-management/intro","title":"Introduction to Response","description":"In both website development and API design, responses play a crucial role in communicating with clients and providing the necessary information or resources. Let\'s explore what a response means in the context of both websites and APIs:","sidebar":"tutorialSidebar"},"response-management/join":{"id":"response-management/join","title":"Join","description":"In Phlame, the join function provides a straightforward way to combine multiple segments into a single, properly ordered array output. This functionality is particularly useful when you need to aggregate data from different sources or segments and ensure that the resulting array follows a specific order. Let\'s explore how the join function works and its benefits in API development:","sidebar":"tutorialSidebar"},"response-management/segmentation":{"id":"response-management/segmentation","title":"Segmentation","description":"Segmentation involves organizing and categorizing data or parameters into logical groups for easier management and processing. Phlame provides you with the ability to segment data using the Api:","sidebar":"tutorialSidebar"},"response-management/send":{"id":"response-management/send","title":"Send","description":"In Phlame, the send function serves as a crucial component for handling API responses. This function allows you to send data to clients in a structured format, with options for customizing the response status, format, and additional headers or footers. Let\'s delve into the signature and functionality of the send function in Phlame:","sidebar":"tutorialSidebar"},"routing-guide/dynamic-routing":{"id":"routing-guide/dynamic-routing","title":"Dynamic Routing","description":"Dynamic routing in web development allows for flexible handling of URL paths based on parameters or conditions. Unlike static routing, where routes are predefined, dynamic routes can adapt to various inputs, enabling more versatile functionality.","sidebar":"tutorialSidebar"},"routing-guide/intro":{"id":"routing-guide/intro","title":"Introduction to Routing","description":"What is Routing?","sidebar":"tutorialSidebar"},"routing-guide/setting-source":{"id":"routing-guide/setting-source","title":"Setting Source File","description":"Simplifying Callback Logic with Source Set Function","sidebar":"tutorialSidebar"},"routing-guide/source-type":{"id":"routing-guide/source-type","title":"Source Type Control","description":"In Phlame, the Source class serves as a tool for managing variables and controlling the content displayed on web pages linked to your router. It offers functionality to streamline code organization and enhance the user experience by allowing the developer to adjust the content based on necessary factors.","sidebar":"tutorialSidebar"},"routing-guide/static-routing":{"id":"routing-guide/static-routing","title":"Static Routing","description":"Static routing is a simple method of routing in web development where the URL paths are predefined and directly mapped to specific content or functionality. Unlike dynamic routing, where routes are generated based on certain conditions or parameters, static routes remain constant and do not change unless explicitly modified by the developer.","sidebar":"tutorialSidebar"}}}')}}]);