"use strict";(self.webpackChunktest_api=self.webpackChunktest_api||[]).push([[7865],{419:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var i=n(4848),a=n(8453);const o={title:"Request Authorization",sidebar_position:6},s=void 0,r={id:"handling-requests/auth-method",title:"Request Authorization",description:"The auth function in Phlame provides a streamlined approach to handle authentication within web applications and APIs. This function enables developers to authenticate incoming requests based on authorization headers and tokens, with support for optional prefixing and hashing. Let's explore the documentation for the auth function and how it can be used.",source:"@site/docs/handling-requests/auth-method.md",sourceDirName:"handling-requests",slug:"/handling-requests/auth-method",permalink:"/docs/handling-requests/auth-method",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"Request Authorization",sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Request Parameters",permalink:"/docs/handling-requests/params-method"},next:{title:"Response Management",permalink:"/docs/category/response-management"}},h={},l=[{value:"Function Signature:",id:"function-signature",level:3},{value:"Parameters:",id:"parameters",level:3},{value:"Functionality",id:"functionality",level:3},{value:"Example without hashing",id:"example-without-hashing",level:3},{value:"Example with hashing",id:"example-with-hashing",level:3}];function c(e){const t={admonition:"admonition",code:"code",h3:"h3",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"auth"})," function in Phlame provides a streamlined approach to handle authentication within web applications and APIs. This function enables developers to authenticate incoming requests based on authorization headers and tokens, with support for optional prefixing and hashing. Let's explore the documentation for the ",(0,i.jsx)(t.code,{children:"auth"})," function and how it can be used."]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsx)(t.p,{children:"Due to the importance of autorization, this part of the documentation is highly detailed."})}),"\n",(0,i.jsx)(t.h3,{id:"function-signature",children:"Function Signature:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-php",children:"public static function auth($prefix , $token , $hash , $then , $orelse, $allowfail)\n"})}),"\n",(0,i.jsx)(t.h3,{id:"parameters",children:"Parameters:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"$prefix"}),": Optional. A string representing the token prefix. Default is null."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"$token"}),": Optional. A string representing the authentication token. Default is null."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"$hash"}),": Optional. A string representing the hashing algorithm to be applied to the authorization header. Default is null."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"$then"}),": Optional. A callback function to execute when authentication is successful. Default is null."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"$orelse"}),": Optional. A callback function to execute when authentication fails. Default is null."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"$allowfail"}),": Optional. A boolean to allow custom orelse code when authentication fails. Default is false. [It does not allow orelse code]"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"functionality",children:"Functionality"}),"\n",(0,i.jsx)(t.p,{children:"The auth function in Phlame offers a comprehensive set of functionalities to handle authentication within web applications and APIs. It begins by retrieving the authorization header from the incoming request and proceeds to check for its presence. In case the authorization header is missing, the function responds with a 401 Unauthorized status code, indicating a lack of authentication credentials. Additionally, the function provides optional support for applying hashing to the authorization header using a specified algorithm, enhancing security measures."}),"\n",(0,i.jsx)(t.p,{children:"Moreover, developers have the flexibility to specify a prefix for the authentication token, allowing for seamless integration with various authentication schemes. Following this, the function compares the provided token with the authorization header. If they do not match, signifying failed authentication, the function returns a 403 Forbidden status code, restricting access to protected resources."}),"\n",(0,i.jsx)(t.p,{children:"Furthermore, the auth function supports the execution of callback functions based on the authentication status. If authentication is successful, the then callback is executed, enabling developers to implement custom logic for authorized requests. Conversely, if authentication fails, the orelse callback is triggered, providing developers with the opportunity to handle authentication errors gracefully."}),"\n",(0,i.jsx)(t.p,{children:"Ultimately, the auth function returns an array containing the authentication status (status) and the authorization header (data). This comprehensive approach to authentication empowers developers to enforce security measures effectively and control access to sensitive resources within their applications."}),"\n",(0,i.jsx)(t.h3,{id:"example-without-hashing",children:"Example without hashing"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-php",children:"Api::auth(\r\n    prefix: \"Bearer\",\r\n    token: \"authentication_token\",\r\n    then: function($rout) {\r\n        // Custom logic for successful authentication\r\n        // Access $rout['data'] to get the authorization header\r\n    },\r\n    orelse: function($rout) {\r\n        // Custom logic for failed authentication\r\n        // Access $rout['data'] to get the authorization header\r\n    },\r\n    allowfail: true\r\n);\r\n\n"})}),"\n",(0,i.jsxs)(t.admonition,{type:"info",children:[(0,i.jsx)(t.mdxAdmonitionTitle,{}),(0,i.jsx)(t.p,{children:"if you dont want to use prefix, you can just add the prefix to the start of the token directly\r\nExample:"}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-php",children:"Api::auth(\r\n    token: \"Bearer authentication_token\",\r\n    then: function($rout) {\r\n        // Custom logic for successful authentication\r\n        // Access $rout['data'] to get the authorization header\r\n    },\r\n    orelse: function($rout) {\r\n        // Custom logic for failed authentication\r\n        // Access $rout['data'] to get the authorization header\r\n    },\r\n    allowfail: true\r\n);\r\n\n"})})]}),"\n",(0,i.jsx)(t.h3,{id:"example-with-hashing",children:"Example with hashing"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-php",children:"Api::auth(\r\n    token: \"your_hash_with_prefix_and_token\",\r\n    hash: \"hash_method_used_for_hashing_the_token\",\r\n    then: function($rout) {\r\n        // Custom logic for successful authentication\r\n        // Access $rout['data'] to get the authorization header\r\n    },\r\n    orelse: function($rout) {\r\n        // Custom logic for failed authentication\r\n        // Access $rout['data'] to get the authorization header\r\n    },\r\n    allowfail: true\r\n);\r\n\n"})}),"\n",(0,i.jsx)(t.p,{children:"Above, the user can be given the token:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-txt",metastring:'title="Readeable Token"',children:"Bearer HelloWorld\n"})}),"\n",(0,i.jsx)(t.p,{children:"but to use the hash, both must be hashed together while being put into the token parameter"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-txt",metastring:'title="sha256 hash"',children:'44ce1c5513af128a297a0b133a98b32499bc11746ace4ae3c02b11f95ab0a775\r\n// this is the sha256 of "Bearer HelloWorld"\n'})}),"\n",(0,i.jsx)(t.p,{children:"The hashing is done only on the server side, to avoid API Key's and Tokens being exposed in the backend."}),"\n",(0,i.jsx)(t.admonition,{type:"caution",children:(0,i.jsxs)(t.p,{children:["Not setting ",(0,i.jsx)(t.code,{children:"allowfail"})," to ",(0,i.jsx)(t.code,{children:"true"})," will cause the ",(0,i.jsx)(t.code,{children:"auth"})," method to break out, to prevent any issues, this will return an error statement and a status code, this will also not allow your orelse callback to run. To prevent the exit, set ",(0,i.jsx)(t.code,{children:"allowfail"})," to ",(0,i.jsx)(t.code,{children:"true"}),"."]})})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(6540);const a={},o=i.createContext(a);function s(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);